hello zy:
	org 0x7c00
	int 0x10,显示字符  p46
		al 要显示的字符
		ah = 0x0e
		bh = 0
		bl = 颜色代码
		返回值 无
	hlt 暂停cpu
	0x0a 换行
	resb 0x7bfe 填充0
	扇区结束标志 0x55,0xaa

读第二个扇区:
	读到0x0820
	读盘 int 0x13:  p54
		ah=2读;3写盘;4校验;0x0c寻道
		al=扇区数
		ch = 柱面号 0
		cl = 扇区号 2
		dh = 磁头号 0
		dl = 驱动器号 0
		es:bx = 缓冲区地址
		返回值 cf=0没有错误,ah=0
			cf=1有错误,错误号码在ah内


读第二个扇区,失败重复5次:
	int 13,重置驱动器
		ah=0
		dl = 0

读到18扇区:
	读取成功则跳至next

读取10个柱面:
	cl = 扇区号 置为1
	dh+1, 磁头号
		如果dh小于2,则跳转读	
		大于2,则置为0,ch柱面号+1
	CYLS	EQU		10

从启动区执行操作系统,并确认操作系统的执行情况:
	jmp oxc200
	int 0x10,设置显卡模式
		ah=0
		al = 0x3 0x12 0x13:320*200*8位色彩模式,调色板模式 0x61
		返回值无
	将CYLS的值写到内存0x0ff0

8. 32位模式前期准备:
		CYLS=0xff0;读取的柱面数
		LEDS=0xff1;
		VMODE=0xff2;颜色的位数 byte ,8
		SCRNX=0xff4;分辨率的x word 320
		SCRNY=0xff6;分辨率的y word 200
		VRAM=0xff8;图像缓冲区的开始地址 dw 0xa0000
		int 0x16;键盘上各种LED指示灯的状态
			ah=2
			[LEDS] = al


9. 开始导入C语言
	新建bootpack.c文件
	增加HariMain函数,无参无返回


10. 实现HLT
	增加naskfunc.nas文件 p70
	[FORMAT "WCOFF"];制作目标文件的模式
	[BITS 32];制作32位模式用的机械语言

	[FILE "naskfunc.nas"] ;源文件名信息
	GLOBAL _io_hlt  ;

	[SECTION .text];目标文件写了这些之后再写程序
	ret


day04
1. 用c语言实现内存写入
	_write_mem8
	ecx保存addr
	al保存data
	0xa0000-0xb0000,写入15
	[INSTRSET "i486p"]

2. 条纹图案
	i&0xf

3. 挑战指针

6. 色号设定
	init_palette
	set_palette(int start, int end, unsigned char *rgb)
		load_eflags
		cli
		io_out8(0x03c8,start)
		从start到end,io_out8(0x03c9,rbg[0]/4) 为什幺要除4,不懂!
		rgb+=3
		store_eflags
	_io_cli
	_io_sti
	_io_stihlt
	_io_in8
		mov edx,[esp+4]
		mov eax,0
		in al,dx
		ret
	_io_in16
	_io_in32
	_io_out8
	_io_load_eflags
		pushfd
		pop
		ret
	_io_store_eflags

7. 绘制矩形
	void boxfill8(vram,xsize,c,x0,y0,x1,y1)


day05
1. 接受启动信息
	vram
	xsize
	ysize
	init_screen函数

4. 显示字符
	putfont8(vram,xsize,x,y,c,font)

5. 增加字体
	extern char hankaku[4096];

6. 显示字符串
	putfont8_asc(vram,xsize,x,y,c,s)

7. 显示变量值
	sprintf()

8. 显示鼠标指针
	init_mouse_cursor8(mouse,bc)
	putblock8_8(vram,vxsize,pxsize,pysize,px0,py0,buf,bxsize)

9. GDT和IDT的初始化

day06
2. 整理Makefile
	第一行用%,第二行用$*
3. 整理头文件
4. 意犹未尽--解释gdt

	_load_gdtr:
		gdtr是48位寄存器,低16位表示限长,高32位表示基址
		lgdt指令
	struct SEGMENT_DESCRITOR {
		short limit_low,base_low;
		char base_mid,access_right,limit_high,base_high;
	};
	set_segmdesc(sd,limie,base,ar)
	init_gdtidt()
		gdt=0x00270000
		gdt表初始化
		段1初始化 0xffffffff,0x0,0x4092  //92代表代表系统数据段
		段2初始化 0x7ffff,0x280000,0x409a //9a代表系统执行段
		load_gdtr(0xffff,0x270000) 
	

5. 初始化PIC  // programmable interrupt controller 可编程中断控制器

6. 中断处理程序的制作
    inthander21(esp)
        ADR_BOOTINFO
        矩形白色
        字符串 "sdjs"
        无限循环
    extern _inthander21
    _asm_inthandler21
        push es
        push ds
        pushad
        mov eax,esp
        push eax
        mov ax,ss
        mov ds,ax
        mov es,ax
        call _inthander21   //如此大费周章的修改ds es,是因为如果不这么做,c函数将不能正常调用 p131
        pop eax //随便找一个寄存器pop
        popad
        pop ds
        pop es
        iretd
    set_gatedesc(idt+0x21,asm_inthandler21,16,0x8e)  //0x8e是用于中断处理的有效设定
        

day07
1. 获取按键编码
    ioout(pic0_ocw2,0x61);
    data = io_in8(0x60);
    
    显示出来
    
2. 加快中断处理
    struct KEYBUF{data,tag}
    
3/4. FIFO缓冲区
5. 整理FIFO缓冲区
    struct FIFO8{buf,left,right,size,free,flags}
    fifo8_init(fifo,size,buf)
    int fifo8_put(fifo,data)
    int fifo8_get(fifo)
    int fifo8_status(fifo)
    
6. 总算讲到鼠标了
    void wait_KBC_sendready(void)
        for
            io_in8(0x64)&0x2==0;break;
    void init_keyboard(void)
        wait
        out(0x64,0x60)
        wait
        out(0x60,0x47)
    void enable_mouse(void)
        wait
        out(0x64,0xd4)
        wait
        out(0x60,0xf4)  // 0x64是控制和状态端口,0x60是数据端口
        
7. 从鼠标接受数据
    鼠标中断
        out(pic1_ocw2,0x64);
        out(pic0_ocw2,0x62);
        in(0x60)
    mousefifo




